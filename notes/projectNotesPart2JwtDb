# Setting Up Our Server & DataBase Code

- okay so we are just getting back from an aside here where we learned about structuring our databases when we want to have both log in functionality and a ToDo list functionality, we did this from a video where he combines login and the Todo app here:
    - Part 1: https://www.youtube.com/watch?v=l3njf_tU8us
    - Part 2: https://www.youtube.com/watch?v=25kouonvUbg&list=TLPQMDcwNzIwMjMu1MU2D6T5JQ&index=2
- so I will be referencing my notes from those two videos, which are also availible in the 'DataBaseDesign.md' file
- so in the video he is making a fresh server and the app is just going to be a login app basically, I am going to try to mimic what he is doing but making a login for the ToDo app that we made above
- we have set up the base of the code we need for the server.js and db.js files already int eh first implementation, and now we will add the things we need to add proper JWT log in and the new database system
- the first thing we want to do is to change the database in our db.js file that has all of our database config in it, since we now want to use the new database
    - so for me that is changeing the `database: "fluetodo"` property in the `Pool`object to `database: "todoapp"`
- next we need to do is install the `jsonwebtoken` and `bcrypt` modules to our backend server with `npm i jsonwebtoken bcrypt`
- `jsonwebtoken` is the module we use to generate and verify json web tokens, as we may expect, and `bcrypt` is a way for us to encrypt our passwords so we have a way to encrypt the passwords we put in our database so they are not plain text in there
- okay so we are also going to restructure the project a bit right now, since it looks liek the project he makes is structured different when we have more components, but most of the actual code for the todo functionality will not change which is nice
- one of the reasons we are doing this is because we want to be able to use a "router", which is what we use to determine how the application responds to different requests, it decides how to handle requests of different endpoints so that we use the rigth functions for the right requests 
- to do this we are going to make a "routes" directory in our server folder to hold all of the different routes we can get requests to, this is a way of grouping different routes together that handle similar functions
- in the main "server.js" file that used to handle all different incoming requests, like for example `app.get("/login"...)`, we will now have use the `app.use()` function to define a middleware that gets called when a secific route is hit, for example we will group login/registration/verification under a single "/auth" route, so in server.js we will have: `app.use("/auth", require("./routes/loginReg"));`, so we are saying when the client sends a request to "/auth/login" we come here first and see for all "/auth" requests we want to go through the imported file "loginReg", then only in loginReg will we define what happens to the request when it hits a "/login" Endpoint

## Building Registration Route 

- so within the "routes" folder we want to make a file that will deal with the logic for checking the login/register credentials, and deal with generating our JWT tokens (which we have not exlained yet), will just name the file 'loginReg.js'
- inside this file we want to import the use of the express `Router()` method, as well as the database query function that we previously used in all of our "server.js" api calls so we can use that here as well, lastly we want to make a basic export statement:
```
const router = require("express").Router();
const db = require("../db") 

module.exports = router;
```
- from here we can go into our main `server.js` file and add the following route:
```
app.use("/auth", require("./routes/loginReg"))
```
- so what this is telling us is that when we get a request to the `/auth` URI we want the request to get directed to the `loginReg.js` 
- inside the loginReg file we now want to build out the basic functionality for registering logging in, this will not have anything to do with JWT tokens and proper authorization yet, but we want the basic functionality to be there first
- we can start by checking the database functionality for getting user data, since when we either register or log in we are going to want to make sure we can properly return user data and make sure we can do something if the user already exists and stuff


### Building Register SubRoute

- so to start we can add a register route, and we can outline inside the route how we want the functionality of it to work
- we start by knowing when a user logs in or registers the username/email/password combos will be sent to us by the front end as the body of the request
- from there we want to:
    1. destructure the req.body to get info
    2. check if user exists
    3. Bcrypt the user password
    4. Enter the user into database
    5. generate the JWT token

#### Recieve User Info and Check if Already Exists
 
- we will start with just #1/#2:
```
router.post("/register", async (req, res) => {
    try {
        // 1. destructure req.body to get name email password
        const {name, email, password} = req.body;

        // 2. check if user exists (if )
        const user = await db.query(
            "SELECT * FROM users WHERE user_email=$1;",
            [email]
        )
        res.json(user.rows)

        // 3. Bcrypt the user password

        // 4. Enter the user into database

        // 5. generate the JWT token

    } catch (error) {
        console.error(error.message);
        res.status(500).send("Server Error")
    }
})
```
- so here we make our catch clause send back a server error, wwith code 500 specifically which is nicer handling than we did before
- in the actual logic we want to destructure the body info, and then send a request to the server to get all of te user data with amtching emails, so that we can test to see if teh user already exists
- in postman we can test this by sending a test POST request to "http://localhost:5000/auth/register", so here the route in the file is just "register" but the route we actually send to is "/auth/register", since this file is ecapsulated as "/auth", since that is how we set it up in the server.js file
- we also add a body in post man of :
```
{
    "name": "chris",
    "email": "sara@gmail.com",
    "password": "password"
}
```
- and we see we get a repsponse of:
```
[
    {
        "user_id": "981480d3-6ef0-44a7-a655-445bec196356",
        "user_name": "sara",
        "user_email": "sara@gmail.com",
        "user_password": "sara1234"
    }
]
```
- so it returned the data for the email given!, so now we can easily add logic to say NO since this user exists already
- what we want out of this section is that if the database returns any users, we want to deny the request and say the user already esists, so taht would be if `users.rows.length !== 0`
- so we add a little conditional block:
```
// 2. check if user exists (if )
const user = await db.query(
    "SELECT * FROM users WHERE user_email=$1;",
    [email]
);
if (user.rows.length !== 0) {
    return res.status(401).send("User Already Exists")
}
```
- which now will send a error code of 401 and the message user already exists to the client, we can test it in postman with the same credentials and it works again!
- error 401 stands for unauthorized, which is different than 403 forbidden, and in general this seems to be a matter of debate online on what error code is best for account creations fails, some people say 409 is better
- now tht we have confirmed the user does not exist, we can deal with how we want to store the data

#### BCrypt the Password and Store the Data

- we want to use bcrypt to hash the password before storing it, this invovles adding random strings to the font and end of a password, then encrypting that final string with a hash function:
```
// 3. Bcrypt the user password
const saltRound = 10;
const salt = await bcrypt.genSalt(saltRounds);
const bcryptPassword = await bcrypt.hash(password, salt);
```
- so the `saltRounds` is the number of times we want to go through the salting cycle, we define that then make a "salt" with the `bcrypt.genSalt()` function, lastly we get our final password we are going to store with the `bcrypt.hash()` method that we pass both the password and the salt into
- now we finally want to add this new user to our database:
```
// 4. Enter the user into database
const newUser = await db.query(
    "INSERT INTO users (user_name, user_email, user_password) VALUES ($1, $2, $3) RETURNING *",
    [name, email, bcryptPassword]
);
```
- here we are simply entering the new user data as a entry into `users`, and we do this using the `$1` notation that we always use with SQL/postrges, also notice we are giving postgres the `bcryptpassword` and not the regular password 
- if we then make our response `res.json(newUser.rows[0])`, and send a request with new userinfo with postman, we can see the response:
```
{
    "user_id": "173abd54-91eb-4ec8-a0a8-b7b15d453e36",
    "user_name": "link",
    "user_email": "link@gmail.com",
    "user_password": "$2b$10$YLm1H9S59DRl3cIfPDBO1e1dAA52Ws9HrsHx6sfECW5rjJl7jbMNO"
}
```
- and we see the password is completely unrecognizable ("triforce1" was the given password)
- our last step is create a Json Web Token to give back to the client to use for the login session

### Create JWT Generator

- in order to make proper JWTs, we are going to want to also install the the 'dotenv' package with npm on our server, this is what allows us to use the secret keys we keep in the environment variables file: ".env" (.env/dotenv, get it?)
- so with this installed we will create a new '.env' file in the server folder, and define some secret key there, in this case my entire .env file is just `jwtSecret = 'ferbie14'`
- we now want to create a new 'jwtGenerator.js' file, and we will make a new utilities folder for this, which is where we will keep our small files that just do a single thing, a specific function, like in this case making a quick JWT
- so this is where we call the functions for tunring our info that we want to send back to the client into an actual json web token, the code for this is relatively simple:
```
const jwt = require("jsonwebtoken");
require("dotenv").config();

function jwtGenerator(user_id) {
    const payload = {
        user: {
            id: user_id
        }
    };
    return jwt.sign(payload, process.env.jwtSecret, {expiresIn: "1hr"});
};

module.exports = jwtGenerator;
```
- we simply need to import the jwt package, and the dotenv package, which allows us to use the secret key without explicitly importing the file, perhaps this is not trivial since we want to keep the enviromnment variables a hidden file 
- we then define the jwt generator function that only takes a user_id, we will see that this is the user_id of the user that just got created in the loginReg.js file
- we then create a payload, rememebring that the JWT consists of a header, payload, and signature, and our payload here will just be an object consisting of the user_id
    - **NOTE ON OUR PAYLOAD**, as mentioned above, the payload is the part of teh JWT token that we define, we can check this out after by console.logging the payload, and we see for a given user we get:
    ```
    {
        user: { id: 'b82b3509-93f4-4f89-bd91-79f94132d579' },  
        iat: 1689185340,
        exp: 1689188940
    }
    ```
    - and we see the whole payload object, 
    - so the first property of the payload is what we just defined should go in it, the the `user` object with an `id` property, and then we have these weird `iat` and `exp` properties in the payload object
    - `iat` stands for "issued at time", while `exp` is the time of expirey, and these times are in seconds since the initialization of unix, some date in 1970
    - so this is just to keep track of if the token is expired or not
- we then jus return the call to `jwt.sign(payload, process.env.jwtSecret, {expiresIn: "1hr"});` which creates the signature and resulting token for us
- back in the loginReg file we can then simply need to import the jwtGenerator at the start of the file with `const jwtGenerator = require("../utils/jwtGenerator");` and then call this function in the #5 generate JWT section
```
 // 5. generate the JWT token
const token = jwtGenerator(newUser.rows[0].user_id);

res.json({token})
```
- so we create the token with the newly craeted user_id, and then make hat token our response,
- we can test this again in postman and we see we get a crzy JWT token as our response:
```
{
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoiYTllYTBiZGItOTA5Ny00MDAyLWJiOTctMTBjMzU0NDEzNmVjIn0sImlhdCI6MTY4OTAyNzI5MiwiZXhwIjoxNjg5MDMwODkyfQ.GDLfyet7ZQUQW1XaoxNgL9i1jQRRHIxIZ66dnivfDMs"
}
```
- so it worked!
- we will leave this here for now and clean it up later when we build the rest, but first we want to do the same thing for the login route


### Build Login SubRoute

- the login route is going to be very similiar to register since in both cases we are recieving names, emails, and passwords
- we can again break the process down into steps:
    - deconstructing the request
    - checking if the user actually exists by the email
    - checking if the passwords are a match 
    - giving them a JWT token
- we also of course have to define the new login route, which is simple enough:
```
router.post("/login", async (req, res) => {
    try {
        // 1. destructure req.body to get name email password
        const {email, password} = req.body;

        // 2. check if user doesn't exist (if user does not exist, throw error)
        const user = await db.query(
            "SELECT * FROM users WHERE user_email=$1;",
            [email]
        );
        if (user.rows.length === 0) {
            return res.status(401).json("Incorrect Credentials")
        };

        // 3. Check if incoming password === database password
        const validPassword = await bcrypt.compare(password, user.rows[0].user_password)
        if (!validPassword) {
            return res.status(401).send("Incorrect Email Or Password")
        }

        // 4. Give them a JWT Token
        const token = jwtGenerator(user.rows[0].user_id)
        res.json(token)

    } catch (error) {
        console.error(error.message);
        res.status(500).send("Server Error")
    }
})
```
- so above we only deconstruct the email and password, since that is all we need this time, the username doesnt actually have anything to do with authentication
- then we search for the user_mail again wiht a db query, and this time we want to check that there is at least 1 result, if there is not and the length of the db response is 0, we will give the error this time,
- if there is a result, we will then check to see if the passwods are a match using the `bcrypt` tool, here we use the `bcrypt.compare()` function that takes the given password, and the hashed password from the database, I suppose it is able to tell what the oriignal salt and hashing funciton used was and see if the given password recieves the same output
- so we can test what we have so far with postman again, and we see if we enter a fake email and fake password, we get the expected responses, we can also `console.log(validPassword)` the result from the bcrypt compare function to see if we get the `true` result when it is working as well, and it does
- if the login credentials passes all these tests, we finally make a JWT token as we did before, and make that our response
- and again we see that if given correct credentials, this works

## Creating Middleware

- okay so now that we have given the user a JWToken on login, we are going to want the user to send us that token eevrytime they try to do anything with the app on the actual dashboard, or actual bulk of the app, that way since we gave them the token, we know it is them who is trying to make the changes, so this will be like a token that is valid for the extent of their login session (a session token, if you will)
- but this means for all subsequent requests after logging in, we will want to have some middleware that validates the token before it gets routed to our add todos, or edit todos routes, for example
- we do this with validator middleware files, these files will have express routes that take incoming requests before they get to our routes, validate them for the token any other stuff, then they call a `next()` method that sends the request to the next peice of middleware in line, or to the final route 
- so we are going to make a middleware that authorizes the JWT token sent fromt he client, and a middleware that validates user info when trying to login/register, these will be called 'authorization.js' and 'validInfo.js' respectively and be in the "middleware" directory that is within "server"

### JWT Authorization Middleware

- we are making the "authorization" file first, but we are not actually going to implement it yet since we do not have the client giving us any tokens yet
- this is actually pretty simple, we already have the tokens being created and given to the client on login and on register, we just need a function to check whther those the token the client is giving back is the same one we gave to them
- for this we are going to need to import the "jwt" module, and also the "dotenv" module to access our secret keys
- after that, we just amke a simple function that gets the JWT from the header of the incoming request, and then uses the built in "jwt" module method "verify" to verify it is correct:
```
const jwt = require("jsonwebtoken");
require("dotenv").config();

module.exports = async(req, res, next) => {
    console.log("authorization middleware");
    try {
        // grab token from request header
        const jwtToken = req.header("token");

        // check if there is no token given
        if (!jwtToken) {
            return res.status(403).json("Not Authorized");
        }

        // use jwt to verify the token with the secret key, returns the payload of the given JWT token
        const payload = jwt.verify(jwtToken, process.env.jwtSecret);
        req.user = payload.user;
        next();
    } catch (error) {
        console.error(error.message);
        return res.status(403).json("Not Authorized")
    }
}
```
- we see here that the `verify` method returns the payload of the JWT token if verification is successful, so here we set that to be equal to the payload, then we are ammending the incoming request object to add a `user` property that is equal to the the `user` property of the payload, which we can recall we just set above when we created the token with jwtGenerator to be:
```
{
  user: { id: 'b82b3509-93f4-4f89-bd91-79f94132d579' },  
  iat: 1689185340,
  exp: 1689188940
}
```
- **SO now the user id has been added to teh request, and our function that will use this middleware have access to this user id!**
- of course we also have other things built in like the check for if the token is even in the header, and the try/catch block, but it is still relatively simple
- for now we are not oging to implement this into any of the routes, but shortly we are going to use this to verify the JWT tokens before the request gets sent to a different route

### Validate Info Middleware

- now we will work on the "validInfo" file, which is also quite simple
- we simply want to take in the incoming login/register request before it gets to the actual "/login" or "/register" route, and check to see if the email/username/password inf is correct
```
module.exports = (req, res, next) => {
    console.log("vaidate info middleware");
    const { name, email, password } = req.body;

    function validEmail(userEmail) {
        return /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(userEmail);
    }

    if (req.path === "/register") {
        if (![email, name, password].every(Boolean)) {
            return res.status(401).json("Missing Credentials");
        } else if (!validEmail(email)) {
            return res.status(401).json("Invalid Email Address");
        }
    } else if (req.path === "/login") {
        if (![email, password].every(Boolean)) {
            return res.status(401).json("Missing Credentials");
        } else if (!validEmail(email)) {
            return res.status(401).json("Invalid Email Address");
        }
    }

    next();
};
```
- we do this by first defining a function that checks if the email is a valid email address, now I am not too sure how it does this at the moment, but it seems we are using a "regular expression" object, which is enclosed by `//`, and has a number of escape keys in it such as `\w` or `\.`, but either way this makes sure we have an `@` symbol for example, or that we dont have unallowed characters like `&` or `$`, and have a `.` for `.com`
    - we run the `test()` method on this expression though, which looks for a match between the crazy regular expression and the `userEmail` string, so that wild regula rxpression defines the amtching condition that looks like a typical email apparently
- we then chck the path for register or login, and in each we see if the body actually contained an email, name, and passwrod with the `if (![email, name, password].every(Boolean))` line
    - the `Array.every(function)` method tests all elements of an array to see if they return a True value when given to the provided function, and the overall `.every()` only returns True if all elements pass
    - here we give the simple Boolean function, which just puts all elements into Boolena form, so it will return false if there is an empty string for any of the name/email/passwrod, and thus `every()` will be false
- after we confirm all elements are there we check is the email is valid with the defined email validatorr function we discussed 
- the login check is the same thing except we do not check for the name since we do not require giving a name to login, only to register
- if all checks pass we call the `next()` method that sends the request tot eh next route in line, which will be the "/login" and "/register" routes
- to implement this now go into the "loginReg.js" file, which is where we deal with the actual "/login" and "/register" routes, and we are able to add a middleware stack in the route handlers, for exampe, we add `validInfo` to as the middleware for the register POST request below:
```
// -- loginReg.js File -- //
const validInfo = require ("../middleware/validInfo")
...
...
// registering
router.post("/register", validInfo, async (req, res) => {
    console.log("register endpoint");
    try {
        ...
        ...
```
- so how the routing works is that requests to "/register" get sent here in the loginReg.js file, then when they hit this handler, beofre the callback function is called, the request goes to `validInfo` first, then when `next()` is called within `validInfo`, the request comes to the next middleware inline, which is now this callback function since we have defined no other middlewares here
- we can see that we could define multiple middlewares in a list here for the request to go through before it hits our callback, we could have `middlewares = [mw1, mw2, mw3]` with each `mw#` being a defined middleware function, then we could call `router.post("/route, middlewares, async (req, res) => {...`, so we can create long chains of handling the request before it reaches the endpoint
- neat
- **note,** we do this for the login route as well: `router.post("/login", validInfo, async (req, res) => {`
- so what this is doing for us on the broad scale is when the request for registering/logging in comes in, we direct it to validInfo first to verify that the info is even valid before we start making database calls and messing with it, that way we dont waste our time with the db when we do not need to, 

## Adding Private Routes

- Private routes are going to be routes that the user has to be logged in in order to access, so we are going to want to build a route on our backend that verifies if the user is logged in before they can access their todo list for example
- so the main page from react is going to make a request to our backend to set the authenticated state to either true or false

### Verify Authorization SubRoute

- so we are going to implement a third route in the loginReg file whose job is just to verify that we are authorized, after we are logged in/registered
- to do this we are finally going to use the "authorization.js" file that we made earlier:
```
const jwt = require("jsonwebtoken");
require("dotenv").config();

module.exports = async(req, res, next) => {
    console.log("authorization middleware");
    try {
        // grab token from request header
        const jwtToken = req.header("token");

        // check if there is no token given
        if (!jwtToken) {
            return res.status(403).json("Not Authorized");
        }

        // use jwt to verify the token with the secret key
        const payload = jwt.verify(jwtToken, process.env.jwtSecret);
        // console.log("user payload:");
        // console.log(payload.user);
        req.user = payload.user;
    } catch (error) {
        // console.log("Auth Error:");
        console.error(error.message);
        return res.status(403).json("Authoization: Not Authorized")
    }
    console.log("authorization: end of function");
    next();
}
```
- so again this middleware is simply going to check if we have a JWT token, and if so try and verify it using the `jwt` modules built in verify method, if all is good we then we call `next()` to send this to the next step in the cahin, however we do not have any route calling this middlewar yet
- so now we want to make a route for log in verification, when a user opens the webpage, we want to be able to verify them if they still have a valid token, or if they simply refresh the page or move to a different page, we want to verify their token to ensure they are the same user
- so to do this we will make a very simple "/verify" route for the client to send these checks to, and this route will use "authorization.js" as its middleware:
```
// -- loginReg.js File -- //
const authorization = require("../middleware/authorization");
...
...
router.get("/verify", authorization, async (req, res) => {
    try {
        console.log("Verify Endpoint");
        res.json(true);
    } catch (error) {
        console.error(error.message);
        res.status(500).send("Server Error")
    }
})
```
- so when the client sends a GET fetch request to "/verify", first the authorization middleware gets called and if the JWT token is invalid it returns a "Not Authorized" status (as we see in theauthorization.js file), and if the token is valid then `next()` is eventually run and the request gets sent to the callback here instead, and so here in this callback all we want to do is send the response `res.json(true);`
- we are only sending back `true` since we know if the request made it to the callback then it is verified, since it got through "authorization.js", so we let teh client set the authorized state to `true`
- **also note** we added the `user` part of the JWT payload to the `req` in the authorization function, but we do not use it here in "/verify" since we just want to verify the toekn is a match, we will use the `req.user` property later in the dashboard route

### Dashboard Route

- so now we want to build the dashboard route, this is where we are actually going to load the user info to the page
- this is a private route because the user cannot access this unless we have confirmed that they are verified with the JWT verification/authorzation process
- for this we are going to define a new middleware class in the "server.js" file, we will do it in the same way we did for the "/auth"/loginReg route:
```
// dashboard route
app.use("/dashboard", require("./routes/dashboard"));
```
- so the above was added to server.js, so now when the client sends a request to "/dashboard" we deal with it with the dashboard.js file
- now we can make the start of the dashboard.js file, we wil create it in the routes folder, and for this we just want to extract all of teh user data after the user logs in to build to the dashboard that displays the user data, so we will want to make a simple GET request
```
const router = require("express").Router();
const authorization = require("../middleware/authorization"); 
const db = require("../db");

router.get("/", authorization, async (req, res) => {
    try {
        // console.log("dashboard/ route");
        res.json(req.user.id);
    } catch (error) {
        console.error(error.message);
        res.status(500).json("Dashboard: Server Error");
    }
});

module.exports = router;
```
- so we import the `router` package since we are using this as a seperated route, and we also are going to use the `authorization` utility since we want to make sure the user is authorized before we fetch their data, and of course we need `db` to access teh database
- we have a simpel GET request here, with a defined `authorization` middleware, and to test it right now all we want to do is send back a response of `res.json(req.user.id);`
- so we can test this in postman, and we can track how this `req.user` object came to be here
    1. postman (or the client) sends a `login` request to the "auth/login" route with the user info like:
    ```
    {
        "email": "zelda2@gmail.com",
        "password": "zelda2"
    }
    ```
    2. the request gets sent to server.js since this is the homebase of our express server so to speak, and `app.use("/auth", require("./routes/loginReg"));` nibbles up this tasty request since its first route is "/auth" and lets the `"./routes/loginReg"` middware deal with it
    3. inside login.js, this request gets picked up by `router.post("/login", validInfo, async (req, res) => {` since it was to "/auth/login", and this handler sends it over to the `validInfo` middleware before deaing with it
    4. inside `validInfo` we simpyl make sure all the info we want is included, and that the email address is valid, if so then we call `next();` to send it to the next middleware inline, which is none, so it gets sent to the "/login" handler callback
    4. in the "/login" callback we extract the `"email"` and `"password"` properties from the intial request sent by postman (or the client), and use these to grad the user info **including user_id** from the database and confirm the password with bcrypt, then if eveything is good we call `jwtGenerator` and give it the user_id we just extracted from the database with the line `const token = jwtGenerator(user.rows[0].user_id)` to make a JWT token
    5. inside `jwtGenerator`, we set the payload of the JWT to `{ user: {id: user_id} }` giving it the `user_id` that was extracted from the database and given to `jwtGenerator`, we then create and sign the toekn with `jwt.sign(payload, process.env.jwtSecret, {expiresIn: "1hr"})` which uses the apyload we just set, the secret from our hidden enviornment variables, and the expiration time to make a signed token, the payload of which ends up looking like:
        ```
        {
            user: { id: 'b82b3509-93f4-4f89-bd91-79f94132d579' },  
            iat: 1689185340,
            exp: 1689188940
        }
        ```
        - and the base64 token itself looks somehing like: 
        ```
        eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoiYjgyYjM1MDktOTNmNC00Zjg5LWJkOTEtNzlmOTQxMzJkNTc5In0sImlhdCI6MTY4OTE4NTM0MCwiZXhwIjoxNjg5MTg4OTQwfQ.r462uqbG5UfntqwxoRc6n8ucnKRWBEUzdRE5nIErv6A
        ```
    6. fianlly the "/login" handler inside "loginReg.js" sends back this token to the client (or postman) with `res.json(token)`
    7. now we can send a request to load our user data since we are logged in, and we do this by sending a GET request in postman (or behind the scences in our client) to "dashboard" with a header of 
    ```
    token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjp7ImlkIjoiYjgyYjM1MDktOTNmNC00Zjg5LWJkOTEtNzlmOTQxMzJkNTc5In0sImlhdCI6MTY4OTE4NTM0MCwiZXhwIjoxNjg5MTg4OTQwfQ.r462uqbG5UfntqwxoRc6n8ucnKRWBEUzdRE5nIErv6A`
    ```
    8. once again, this request gets sent to server.js first, and this time this nasty little morsel is gobbled up by `app.use("/dashboard", require("./routes/dashboard"));`, which sends the request straight over to the middleware `"./routes/dashboard"`
    9. inside dashboard.js, we only have a single route, a "/" GET, and since the route from postman was just "/dashboard" and was also a GET request, this picks it up: `router.get("/", authorization, async (req, res) => {`, this handler sends the request first to the defined `authorization` middleware to make sure we have the right credentials
    10. inside authorization.js, we first grab the `token` that postman (or client) set in the header with `const jwtToken = req.header("token")`, and make sure it actually exists with a quick check, 
        - then we use the built in `jwt.verify()` method of the `jwt` package to verify that the JWT token is valid: `const payload = jwt.verify(jwtToken, process.env.jwtSecret)`, this `jwt.verify()` method will return the decoded payload of the JWT, 
        - recall in step (5.) that the payload of the JWT includes the `user` object: `{ user: {id: user_id} }` along with expiration/creation times, 
        - therefore in the next line we do: `req.user = payload.user;`, creating a `user` property in the request object that is equal to `payload.user`, thus adding the `user_id` of the user trying to see their dashboard to the `req` object
        - now finally we call `next()`, sending this request to the callback function of the `router.get("/", ... ...` in dashboard.js
    11. inside the callback, we now have access to he verified users `user_id` through `req.user.id` and we send this back to postman in a response, and in postman we get `"b82b3509-93f4-4f89-bd91-79f94132d579"`, the correct `user_id`!!!
- so now what we want to do is instead of just sending back the `user_id`, we want to use that `user_id` to make a postgres query to get all the user info, including that users todos with the database we made in the relational database part of this tutorial
- **so below we deviate from the JWT tutorial video, and start encompassing bits from the JWT/PERN-Todo combined video**
- so to make our backend send back the actaul useful user info, we want to make a database query with our db module that we made/imorted:
```
router.get("/", authorization, async (req, res) => {
    try {
        console.log("dashboard: route");
        // console.log(req.user.id);
        const user_data = await db.query(
            "SELECT u.user_name, t.todo_id, t.description FROM users as u LEFT JOIN todos as t ON u.user_id = t.user_id WHERE u.user_id=$1",
            [req.user.id]
        )
        // console.log(user_data.rows);
        res.json(user_data.rows);
    } catch (error) {
        console.error(error.message);
        res.status(500).json("Dashboard: Server Error");
    }
});
```
- so here instead of just sending back `req.user.id`, we make a database query with `const user_data = await db.query()`, and we make our query `"SELECT u.user_name, t.todo_id, t.description FROM users as u LEFT JOIN todos as t ON u.user_id = t.user_id WHERE u.user_id=$1"`, which is alot but we will go over it
    - the basis of this query is just the regular LEFT JOIN query that we learned when going over relational databases, we can simplyfy this query as the typical `"SELECT * FROM users LEFT JOIN todos ON users.user_id = todos.user_id;"`, which is alot more familiar, where we are getting all the info (*) from rows in the `users` table, and combining those that have todos with matching `user_id`'s to make a number of records, and since it is a LEFT JOIN we make all teh combinations of user/todo with amtching records, and also return all users that do not have todos
    - the first new thing we are going to do is just introduce an alias for the reference of `users` and `todos` of `u` and `t` respectively since we state the table names alot in this query, we do this with the `users as u` and `todos as t` clauses in the first instance where we refence the tables directly, so now in the rest of the query we can just use `u` and `t`, this would change our simple starting query to `"SELECT * FROM users as u LEFT JOIN todos as t ON u.user_id = t.user_id;"`
    - now we want to filter those resutls down with a WHERE clause, which we are also familiar with, by saying `WHERE u.user_id=$1`, and of course `$1` stands for the reference we pass into the array, the user_id we want to get data for, so now our query is `"SELECT * FROM users as u LEFT JOIN todos as t ON u.user_id = t.user_id WHERE u.user_id=$1` which completes the task of getting all the data from the proper combo matches we want
    - the last part is to not grab all data **otherwise we would be giving the passwords of the users to the client**, so we want to change the `*` to just be the data we want, in this case we want the user_name, the todo descriptions, and the todo ids, so we replace `*` with `u.user_name, t.todo_id, t.description`, and now we arrive at our final query: `"SELECT u.user_name, t.todo_id, t.description FROM users as u LEFT JOIN todos as t ON u.user_id = t.user_id WHERE u.user_id=$1"`
- so to reiterate **IT IS VERY IMPORTANT WE SELECT ONLY THE DATA WE NEED TO SHOW THE USER, OTHERWISE WE GIVE THE USER PASSWORD TO THE CLIENT**
- so the user/todo data should now be set as user_data, and we can send this response back to postman, or the client, with `res.json(user_data.rows);`
- and as we expect, in postman we can try this with a logged in user, and get the respnse:
```
[
    {
        "user_name": "zelda2",
        "todo_id": 4,
        "description": "zelda todo"
    },
    {
        "user_name": "zelda2",
        "todo_id": 5,
        "description": "slay gannon ;)))))"
    },
    {
        "user_name": "zelda2",
        "todo_id": 6,
        "description": "get saved buy link"
    },
    {
        "user_name": "zelda2",
        "todo_id": 7,
        "description": "buy a gallon of PCP"
    }
]
```
- so a list of each of the todo combos from the user we filtered by with `user_id`!!!!
- perfecto

## Adding / Modifying Our Todo Route Handlers to the Dashboard Route

- okay so now we want to add the functionality to do all the things with the todo list that we wanted to do previously, like add a todo, edit a todo, get all todos, delete a todo, etc
- now we already have all this functionality from the first iteration of the app, we just need to modify it a bit since we will now be referencing todos to our database with user_id as well, since we need to only be modifying our own todos, also we want to add authorization middleware to each of these handlers to ensure the person modifying them is still loged in and stuff
- we are going to add these to the dashboard parent route, since the dashboard is  where we are loading all of the user info, and now we want to display their list to them here

### Create a Todo

- the original create a Todo handler is in the server.js file and looks like:
```
app.post("/todos", async(req, res) => {
    try {
        const { description } = req.body;
        const newTodo = await db.query(
            "INSERT INTO todo(description) VALUES($1) RETURNING *", 
            [description]
        );
        res.json(newTodo.rows[0]);
    } catch (err) {
        console.error(err.message);
    }
})
```
- the main reason we cant just use this exact method as is is because we need to now be able to specify the `user_id` of the todo being created, since now all todos need to have a foreign key `user_id`
- so in the new handler, that we will put inside dashboard.js, will first be called with the `router.post()` syntax since we are using `router` to route the request to here from server, and will need to also call the `authorization` middleware to verify the user and also add the `user_id` to the request body as `req.user.id` as it did in the "/" dashboard route above:
```
router.post("/todos", authorization, async(req, res) => {
    try {
        const { description } = req.body;
        const newTodo = await db.query(
            "INSERT INTO todos(user_id, description) VALUES($1, $2) RETURNING todos.todo_id, todos.description", 
            [req.user.id, description]
        );
        res.json(newTodo.rows[0]);
    } catch (error) {
        console.error(error.message); 
    }
})
```
- so here we see teh `router` and `authorization` changes, and besides that we also see the query has changed
- we now specify both `(user_id, description)` instead of just `(description)` as the insert variables, and we also only reutrn the `todos.todo_id, todos.description` instead of `*`, which is less important here than in the above GET all route since there is no password info here, but it is good to return only the info we need 
- besides that it is pretty much the same, so the implementation is relatively simple!
- all of the next routes are also going to use the `router` class, and also will call the `authorization` middleware, so we wont go over that everytime, we will only go over the major changes

### Update a Todo

- original update code:
```
app.put("/todos/:id", async(req, res) => {
    try {
        const { id } = req.params;
        const { description } = req.body;

        const updateTodo = await db.query(
            "UPDATE todo SET description=$2 WHERE todo_id=$1 RETURNING *",
            [id, description]
        );
        res.json(updateTodo.rows[0])
    } catch (err) {
        console.error(err.message);
    }
})
```
- once again here we need to be able to only be allowed to update our own todos, so we need to specify the `user_id` in the query, or else you could easily find a way to change other peoples todos
- we do this in the new code with:
```
router.put("/todos/:todo_id", authorization, async(req, res) => {
    try {
        const { todo_id } = req.params;
        const { description } = req.body;

        const updateTodo = await db.query(
            "UPDATE todos SET description=$3 WHERE (user_id=$1 AND todo_id=$2) RETURNING todos.todo_id, todos.description",
            [req.user.id, todo_id, description]
        );

        if (updateTodo.rows.length === 0) {
            return res.json("this todo is not yours")
        }

        res.json(updateTodo.rows[0])
    } catch (error) {
        console.error(error.message);
    }
})
```
- so there are some minor changes like we turned `id` into `todo_id`, but the main major changes come in the query where we now use the WHERE clause to search for `WHERE (user_id=$1 AND todo_id=$2)` so we only retrun todos that match the `user_id` from the JWT token AND the `todo_id` from the URL param
- this is important since the user cannot control the JWT token, so they can not just send us a different `user_id` with a fake URL if they wanted, they dont have control over the `user_id` so it restricts them to their own stuff
- the other major change is the addition of the check for if the returned database query has no rows, which happens either if the `todo_id` has not been created, or if the `todo_id` that was sent does not belong to the given `user_id`, so we send a reply of "this todo is not yours", 
    - this cehck isnt neccisarily needed since the database query itself will prevent anything being accessed that shouldn be accessed, but it is good to have a reply if something went wrong and nothing showed up

### Delete a Todo

- old code:
```
app.delete("/todos/:id", async(req, res) => {
    try {
        const { id } = req.params;

        const deleteTodo = await db.query(
            "DELETE from todo WHERE todo_id=$1 RETURNING *",
            [id]
        );
        res.json(deleteTodo.rows[0])
    } catch (err) {
        console.error(err.message);
    }
})
```
- once again, the same issue where we dont want peopel to delete other peoples todos:
```
router.delete("/todos/:todo_id", authorization, async(req, res) => {
    try {
        const { todo_id } = req.params;

        const deleteTodo = await db.query(
            "DELETE from todos WHERE (user_id=$1 AND todo_id=$2) RETURNING todos.todo_id, todos.description",
            [req.user.id, todo_id]
        );

        if (deleteTodo.rows.length === 0) {
            return res.json("this todo is not yours")
        }
        res.json(deleteTodo.rows[0])
    } catch (error) {
        console.error(error.message);
    }
})
```
- the fix here is exactly the same, we use the WHERE clause of `WHERE (user_id=$1 AND todo_id=$2)` to make sure the todo is only returned if it belongs to the right user, and we also add in the check afterward again to send the "not your todo" response

### Bonus: Search Todos

- so this never made it into production on the client side, but I want to implement it here, old search todos code:
```
app.get("/todos/search/:search", async(req, res) => {
    try {
        const { search } = req.params
        const allTodos = await db.query(
            "SELECT * FROM todo WHERE description LIKE ('%' || $1 || '%') ORDER BY todo_id asc",
            [search]
        );
        res.json(allTodos.rows)
    } catch (err) {
        console.error(err.message);
    }
})
```
- once again, this will return all todos that fit the search, not just the users, need to fix:
```
router.get("/todos/search/:search", authorization, async(req, res) => {
    try {
        const { search } = req.params
        const allTodos = await db.query(
            "SELECT * FROM todos WHERE (user_id=$1 AND (description LIKE ('%' || $2 || '%'))) ORDER BY todo_id asc",
            [req.user.id, search]
        );
        res.json(allTodos.rows)
    } catch (error) {
        console.error(error.message);
    }
})
```
- so now we have a complex query with a WHERE clause of `WHERE (user_id=$1 AND (description LIKE ('%' || $2 || '%')))`, so we need the description LIKE to match, and the `user_id` to match for it to be reutrned, and testing postman confirm it works awww yeah

# Client Side JWT Addition

- with the above finished we see we have a fully functional backend, we just need to make a front end that con construct these requests for us properly, and format the data how we like
- I am probably going to make this very not aesthetic, and just try to get the functionality down first, then we can fuck with some colour
- so in general we are going to be storing an authenticated or not authenticated state in the parent App.js folder, and when they try to load the login component for example, if we find the user is already authenticated, we are going to just redirect them to the dahsboard, where the todo list will live, and if they are not authenticated, then we load the login page so they can get authenticated
- we are not going to go over state management system like React Context API, or Redux, since these deserve more time and we want to focus on JWT, 
    - however I want to get into these later

## SetUp

- so we have the basis of our react app set up already, we have our react installation, and all of our componenrs we made for our todo list, and our current panding page in App.js is our ListTodo and InputTodos components
- **however** we are going to install `react-router-dom` and `react-toastify`, 
    - the former lets us create routes different routes on our page, so when we navigate to "http://localhost:3000/about" for example, we bring up a specific view with component for the about page (we are not making an about page, so this is jsut an example), 
    - the latter lets us have little pop up notifications for when we log in or register or soemthing to let the user know we logged in

## React-Router-Dom

- we have used react-router-dom in the movie search project before, but we will go over how we are going to set it up here too
- we set this up in the App.js file, so it will take a bit of modifying to get our current project to still work with the react-router-dom setup, we may just not load any of the todo list components yet until we start working on the dashboard component, since that is where we will actually serve the todo list
- **OKAY WHEN WATCHING THE TUTORIAL I CAME ACROSS OSME QUESTIONS AND DIFFERENCES FROM MY OTHER IMPLEMENTATION OF RRD (REACT ROUTER DOM) IN THE MOVIE SITE, WILL TALK ABOUT THEM HERE**
- **also will add more as i find more things that are different**
    1. we need to import BrowserRouter from RRD, all components that will use RRD need to be excapsulated in a parent Browser Router component, to do this we just wrap the whole ass app in `<BrowserRouter><BrowserRouter />`, but he does it in the video in the App component, just making a parent BrowserRouter component for all the views/components: 
        ```
        function App() {
            return (
                <BrowserRouter>
                    <Route />
                    <Route />
                <BrowserRouter />
            )
        }
        ```
        - but in my experience we instead go into index.js and wrap the App component in browser router:
        ```
        root.render(
            <React.StrictMode>
                <BrowserRouter>
                    <App />
                </BrowserRouter>
            </React.StrictMode>
        );
        ```
        - then in app have our routes and whatnot, so why the difference?
        - from what I can tell, not a lot of reason, people seem to do both, and it seems as though as long as all your components and routes tat are going to rely on BR are inside the component one way or another, we are gucci
    2. Also, he is using the `<Switch>` component to hold all of his `<Route>` comonents in App, but my movie search app thing uses the `<Routes>` component to hold my `<Route>` components, and this is because he is using v5 of RRD, and I use v6
        - there are lots of changes where they say to use newer element types in v6, in the "upgrading" docs here: https://reactrouter.com/en/main/upgrading/v5
        - for example he also passes in his components to `<Route>` via the `render` attribute, but we will use the `element` attribute instead since we can directly define a component element (like `<ListTodo>`) in the `element` attribute, which makes it easier to pass props to those components

### Initial BrowserRouter

- okay so after that aside we can finally set up the routing in our app
- first we want to go into index.js and import the `BrowserRuuter` component from react-router-dom, to allow our app to use proper URL style routing:
```
import { BrowserRouter } from 'react-router-dom';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);
```
- we simply wrap the whole `<App />` component in a `<BrowserRouter>` component, that way the entire App has access to teh states and hooks of BrowserRouter

### Adding Routes in App

- we then want to go into our App component and add teh various routes we want to have for our page
- to do this first we are going to create files for the Login component, the Register component, and the dashboard component, I am going to keep Dashboard.js in its own folder (also called dashboard), have Login.js and Register.js in the main Components folder, and move EditTodo.js, ListTodo.js, and InputTodo.js to its own TodoList folder
- we can add very basic functionality to the new Dashboard/Login/Register components, just so they return their compoent name:
```
// Register.js File //
const Register = () => {
    return (
        <>
            <h1>Register</h1>
        </>
    );
};

export default Register;
```
```
// Login.js File //
const Login = () => {
    return (
        <>
            <h1>Login</h1>
        </>
    );
};

export default Login;
```
```
// Dashboard.js File //
const Dashboard = () => {
    return (
        <>
            <h1>Dashboard</h1>
        </>
    );
};

export default Dashboard;
``` 
- back in App.js we also want to import the Routes, Route, and Navigate components from react-router-dom: `import { Routes, Route, Navigate, } from 'react-router-dom';`, and we will also import each of teh components we just made, as well as useState since we will use it for the authentication state
- so with react-router-dom, all of our different website pages, which can consist of mulitple components or just be a single one, are going to be `<Route>` components, all enclosed in a single parent `<Routes>` component
- we then define a path as an attribute in each `<Route>` component, and when the page naviagtes to that URL, that is the route/component that is rendered:
```
function App() {

  return (
    <>
      <Routes>
        <Route 
          exact path="/login" 
          element={
              <Login />
          } 
        />
        <Route exact path="/register" element={<Register />} />
        <Route 
          exact path="/" 
          element={
              <Dashboard />
          }  
        />
      </Routes>
    </>
  );
}
```
- the whack formatting for the login and dashboard elements will make sense later
- but we see all `<Route>` components are enclosed in a `<Routes>` component, and then each of the individual `<Route>` components call one of the components we made with the `element` attribute, and each `<Route>` has a defined path in the `path` attribute
    - so for example, is the user types in "https://localhost:3000/login" they will his that `<Route>` and be directed to the `<Login />` component

### Adding Authentication State and Redirects

- okay so with that we now want to add a simple way to track the state of te user authentication, which we can do easily with the `useState` hook we added
- we can create a state called `isAuthenticated` and have it set to a default boolean value of false: `const [isAuthenticated, setIsAuthenticated] = useState(false);`
- we then want to be able to pass this state into the components, so that the login component can change this state after logging in and being successfully authenticated with a JWT token, so to do that we are going to need to pass a setState function to the components
- **and** we also want a way of making sure the user is not able to load the `<Dashboard />` component if they are not authenticated, as well as not being able to load the `<Login />` component if they are already logged in
- we do this below:
```
function App() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const setAuth = (boolean) => {
    setIsAuthenticated(boolean);
  }

  return (
    <>
      <Routes>
        <Route 
          exact path="/login" 
          element={
            !isAuthenticated ? (
              <Login setAuth={setAuth} />
            ) : (
              <Navigate to="/" />
            )
          } 
        />
        <Route exact path="/register" element={<Register setAuth={setAuth}/>} />
        <Route 
          exact path="/" 
          element={
            isAuthenticated ? (
              <Dashboard setAuth={setAuth} />
            ) : (
              <Navigate to="/login" />
            )
          }  
          setAuth={setAuth}
        />
      </Routes>
    </>
  );
}
```
- so now we have a state for `isAuthenticated`, and we have also create a `setAuth` function that basically just calls `setIsAuthenticated` for us, but this makes it easier for passing the set state functionality as a prop to the components
- in the actual `<Routes>` themselves, we see the `element` attributes have chnages signifcantly, we use the: `condition ? (run if True) : (run if False)` syntax to redirect react-router-dom to a different route if we are or are not autheticated
    - for example in the `<Login>` `<Route>`:
    ```
    element={
        !isAuthenticated ? (
            <Login setAuth={setAuth} />
        ) : (
            <Navigate to="/" />
        )
    }
    ```
    - so if we are not authenticated, the Login component loads as expected, but if we are authenticated, then we redirect the app to the "/" route instead, which we can see is the route with the `<Dashboard>` component
    - and we do the opposite for the dashboard component
- further, since we want each of the Login/Dashboard/Register components to be able to change the `isAuthenticated` state, we also pass in the defined `setAuth` function as a prop to each: `<Login setAuth={setAuth}`
- now for the last step, we want to add a button to test the basic functionality of this to the Login and Dashboard components, that will just have an onClick handler to call `setAuth(true)` and `setAuth(false)` respectively:
```
const Login = ({ setAuth }) => {
    return (
        <>
            <h1>Login</h1>
            <button onClick={() => setAuth(true)} >Login</button>
        </>
    );
};
```
```
const Dashboard = ({ setAuth }) => {
    return (
        <>
            <h1>Dashboard</h1>
            <button onClick={() => setAuth(false)} >Logout</button>
            <InputTodo />
            <ListTodo />
        </>
    );
};
```
- **note, i also added our old Input and ListTodo components to the dasboard to give it some life, they dont work since we changed our backend/db structure, but looks nice**
- and we see now that now if we navigate to the dashboard through the URL by entering just "https://localhost:3000", since the dahsboard route is "/", then we immediately get redirected to "https://localhost:3000/login" since we are not authenticated
- if we then click the login button, `isAuthenticated` gets set to `true` and we are immediately redirect to the dashboard at "https://localhost:3000", then we can click the logout button and `isAuthenticated` gets set to `false` again and we are immediately redirect to "https://localhost:3000/login" again

## Register Component

- so now that we can route to the different components, we want to build out the register component so it looks how we want and actually interacts with the backend and can get that JWT token

### Register Input Form and State

- okay so the first thing to do is to make a form that peopel will input their registration info in, which is easy enough, we have made forms for the InputTodo component already:
```
const Register = ({ setAuth }) => {
    const [inputs, setInputs] = useState({
        name: "",
        email: "",
        password: ""
    });
    const updateInputs = (e) => {
        setInputs({...inputs, [e.target.name]: e.target.value});
    };
    return (
        <>
            <div className="container">
                <div className="row text-center mt-5">
                    <h1>Register</h1>
                    <form onSubmit={onSubmitForm} className="w-100 mt-3 d-flex flex-column justify-content-center align-items-center">
                        <input 
                            value={inputs.name} 
                            onChange={updateInputs}
                            type="text" 
                            name="name" 
                            placeholder="Username"
                            className="w-50 form-control d-flex justify-content-center border border-1 border-secondary-subtle mb-3" 
                            />
                        <input 
                            value={inputs.email} 
                            onChange={updateInputs} 
                            className="w-50 form-control d-flex justify-content-center border border-1 border-secondary-subtle mb-3" 
                            type="email" 
                            name="email" 
                            placeholder="Email Address" 
                        />
                        <input 
                            value={inputs.password} 
                            onChange={updateInputs} 
                            type="password" 
                            name="password" 
                            placeholder="Password" 
                            className="w-50 form-control d-flex justify-content-center border border-1 border-secondary-subtle mb-3"      
                        />
                        <button className="w-50 btn btn-success btn-block">Submit</button>
                    </form>
                </div>
            </div>
        </>
    );
};
```
- so we have a bunch of bootstrap calsses and stuff but the basis of it is quite simple, it is just a `<form>` element with 3 `<input>` elements, one for name, email, and password, and finally a `<button>` for submitting the whole thing
- we see that we have defined a state called `inputs` that we use to hold each of the `name`,`email`, and `password` states in an object, we are going to use the typical `onChange` method with react where we set each of the input `value` attributes to be `input.name` for example, then update the value by calling an `onChange` handler, in this case `updateInputs()`
- we use the same event handler for all of the inputs, and this way every time an input changes all teh states are updated at the same time, and we can guarentee they are always in sync with what is on the screen
- inside `updateInputs()`, we simply call the `setInputs` function, with: `setInputs({...inputs, [e.target.name]: e.target.value});`, which looks confusing at first, but the `...inputs` syntax is just called a "spread" operator

    #### Long Aside on {[]} Notation

    - what this does is just call on each item of a iterable, so we have compressed the iterable, witht he commas and stuff so they are still seperate items, into the `...inputs` reference
    - so when we just call `{...inputs}` for example, we are just cloing the inputs object
    - however in addtion, we are adding another item to the object with the second term `[e.target.name]: e.target.value`, which for the `name` input would be `['name']: value`, and when definign an object literal like this, this defines a new item, which will overwrite the previous item with the key of `name` already in the object from the `...inputs` cloning
        - in general, the last one in line always wins, it just overwrites each time
    - I am not sure why we have to define it in square paranthesis like an array, we see if we remove the paraenthesis we can not compile, and if we do something like `String(e.target.name)` to cast it into a string, then it still doesnt work
    - **Further testing**, if we `console.log([e.target.name])` in the function, we get a printout of `["name"]`, so just the input name in an array in a string, but if we `console.log(e.target.name)` we get `name`, so no string at all
    - then if we do `console.log({[e.target.name]: 'test'})`, we get a proper object printed out of `{name: 'test'}`, so the `name` key is not in a array or even represented as a string liek it is when we log `[e.target.name]` alone
    - we also see if we `console.log({e.target.name: 'test'})` we get an error! this doesnt work either, so it seems in the object literal notation, we have to use the square brackets to identify that we are calling a variable or object properties 
    - we can confirm this by setting a variabel in the function `const test1 = 'chris'`, then try `console.log({test1: 'test'})`, **and we see the printout is:** `{test1: 'test'}`, so it doesnt even recognize the variable, and if we do `console.log({[test1]: 'test'})`, **the printout is now:** `{chris: 'test'}` **WOW**
    - so i guess this is just a pice of JS that went over my head, inside objects we have to use square brackets as an "escape" to reference variables for keys from outside
    - this makes sense since arrays cannot be keys anyway since they are mutable, and mutable bjects cannot be keys
    - **one last test**, we can try the same thing on the value side of the object, with the same `const test1 = 'chris'` definition, we can do `console.log({test: test1})` and we see the reference works and we printout `{test: 'chris'}`, and if we do `console.log({test: [test1]})`, this time we actually cast the reference into an array and get `{test: ['chris']}`
    - good stuff
- okay back to the real world

### OnSubmit Form Handler and Fetch API

- now we want to add an onSubmit handler to the form so that we can actually submit this info and call teh API, this is quite easy since we know exactly the information our backend wants to recieve:
```
const onSubmitForm = async (e) => {
        e.preventDefault()
        try {
            const body = { ...inputs }
            const response = await fetch("/auth/register", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
            })
            const data = await response.json()
            // console.log(data);
            localStorage.setItem("token", data.token)
            setAuth(true)
        } catch (error) {
            console.error(error.message);
        }
    }
```
- so when the button is submitted, we create a copy of the current state of the inputs with and put it int he `body` reference with `const body = { ...inputs }`
- i will say I think the guy in the video made this harder on himself, he instead declares further variables in the component scope, saying `const { name, email, password } = inputs`, and then sets them to body in the handler with `const body = { name, email, password }` which works fine and they get updated everytime the compoennt updates, which is when the state changes, so they are alwasy up to date, but we can simply just reference inputs directly here with the spread notation like I do above
    - he also uses them in his inputs for the html, defining the input names as `name={email}`, where I do `name={inputs.email}`, I liek my direct approach, we will see if it comes back to get me
- we then make a simple fetch POST request liek we did with the InputTodo compoennt before
- we want to make it to the register route, and we know that first has to go to the "/auth" routh, which calls the "loginReg" middleware, so our route is "auth/register"
- we also have to define our fetch options object since it is not a simpel GET, so we define the method as POST, and the headers `content-type` liek we did before, and we also of course have to define the body, by using `body: JSON.stringify(body)` to get the inputs we put into `body` in there as a proper JSON string
- we know from our backend that the register route is going to make a new user in the database with this info, and then send us back a fresh JWT authenticaion token, so we have to convert that JSOn to accept taht token with `const data = await response.json()`
- and now we have to actually interact with our browser, which os cool! We have to add this token to the local storage on our browser with `localStorage.setItem("token", data.token)`, this sets an object like item to our browsrs local storage of "token" : {actual JWT}"
- lastly we call `setAuth(true)`, which we passed to the register as a component to change the state of `isAuthenticated` to true now taht we have a token!
- in fact, we can now go into our browser, and inspect, and if this all worked, we can go to the "application" tab of the dev tools, go to the "storage" section on the left, and find the "local storage" tab, and if in there there is likely multiple options, our is the page name, "http://localhost:3000/" in my case, and we can click on it and see a table of all our local storage items, and the only one there for us is "token: eyJhbGciOi...", and it shows the whole token but I shortened it,
- that is really cool, everything worked and now our browser has this token it can use to give back to our backend the next time we want to load the page
- we will see that right now if we go to the "/login" URL , we do not get automatically redirected though since we haven't yet set up the page to not refresh and reset the `isAuthenticated` state to false everytime we reload the page, however we do still want to it call a verify API to test if our token is valid whenever we load a page

## Login Component

- okay so functionally the login route should be pretty similiar to the register route, we want to have an email/passwrod enter form, and a submit button, except we want to hit the login endpoint of the backend instead of register
- we still are going to want to get a token and put it in local storage as well
- i will add the entirety of login here below, since most of it was just copy and pasted, and copy what has changed from register:
```
import { useState } from "react";
import { Link } from 'react-router-dom';

const Login = ({ setAuth }) => {
    const [inputs, setInputs] = useState({
        email: "",
        password: ""
    });
    const updateInputs = (e) => {
        setInputs({...inputs, [e.target.name]: e.target.value});
    };
    const onSubmitForm = async (e) => {
        e.preventDefault()
        try {
            const body = { ...inputs }
            const response = await fetch("/auth/login", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(body)
            })
            const data = await response.json()
            console.log(data);
            if (data.token) {
                localStorage.setItem("token", data.token)
                setAuth(true)
            }
            
        } catch (error) {
            console.error(error.message);
        }
    }
    return (
        <>
            <div className="container">
                <div className="row text-center mt-5">
                    <h1>Login</h1>
                    <form onSubmit={onSubmitForm} className="w-100 mt-3 d-flex flex-column justify-content-center align-items-center">
                        <input value={inputs.email} onChange={updateInputs} className="w-50 form-control d-flex justify-content-center border border-1 border-secondary-subtle mb-3" type="email" name="email" placeholder="Email Address" />
                        <input value={inputs.password} onChange={updateInputs} className="w-50 form-control d-flex justify-content-center border border-1 border-secondary-subtle mb-3" type="password" name="password" placeholder="Password" />
                        <button className="w-50 btn btn-success btn-block mb-3">Submit</button>
                    </form>
                    <Link to="/register">Or Create a New Account</Link>
                </div>
            </div>
        </>
    );
};

export default Login;
```
- so the mojority of the return statement is exactly the same, excet we have gotten rid of the "name" input field, since we want to login with emails instead of name since emails are unique
- we have the same state, and onCHnage handler for the remaining input fields, and since we are just calling the spread operator `...inputs` in the `updateInputs` and `onSubmitForm` handlers we do not need to change the variables to remove `name` at all
- in the fetch request we have changed the route from "auth/register" to "auth/login" of course, and besides that we also added a check to see if we actually get a token back for now:
```
if (data.token) {
    localStorage.setItem("token", data.token)
    setAuth(true)
}
```
- we did this because when I was testing if the login worked correctly, I noticed we got redirected to dashboard with the `setAuth(true)` line even when we entered the wrong password since `setAuth(true)` gets called either way, so I just added as simple cehck to make sure we actually get a token back, which only happens if login is successful, before add the localstorage and `setAuth(true)` to avoid that
    - i imagine we will do a better version of making sure were logged in before redirecting when we have the components done, but this works for now
- the last thing we have added is a link in the HTML to navigate to /register, so the user can click that if they do not have an account, and we also added one to navigate to /login in the register page
- we do this with the `<Link>` component from react-router-dom, which we have to import, it is very simple and looks like: `<Link to="/register">Or Create a New Account</Link>`
- this lets us have a simple button that links to a different `<Route>` that we defined in the App component, and it is nice since we do not have to refresh the page, it just changes to a new route

## Staring Dashboard Component and Updating Old Components

- okay so now we want to make the dashboard component, and this is where we will have to add some things from the original combined JWT/Todos video to make the Todo list all work here in one go, instead of making then remaking the compoennt
- hopefully it goes smoothly, but I will focus on getting the routing/authorization stuff done right frist
- **okay so i lied, we are going to build the barebones dashboard component, but we are also going to make modifications to the ListTodo/EditTodo/InptTodo/DeleteTodo components/functions, so that these all play nicely with our backend API and we can actually have a functioning website before we add in the extra functionality like no logout on refrsh**
- we want our dashboard, our main page, to display the users name, as well as the todo list itself, so our HTML structure for the dashboard is going to look something like:
```
const Dashboard = ({ setAuth }) => {
    const [name, setName] = useState("")
    return (
        <>
            <main className="container mt-4 text-center mt-5">
                <div className="row d-flex flex-column justify-content-center">
                    <h1>{name}'s ToDo List</h1>
                    <InputTodo />
                    <ListTodo />
                </div>
            </main>
            
        </>
    );
};

export default Dashboard;
```
- **note, we chnaged some of the bootstrap styling to make it look more uniform and liek a single component all together when its loaded**
- and so we are going to have to make a fetch request to get the user info
- however, since we already need to make a fetch reqest to get all the Todos of the user, it makes more sense for us to make a single fetch request in the Dashboard component to the "/dashboard/" route we made in the backend, since that endpoint will give us the users name, todo_id, and todo description, for each of teh user's Todos, and thus we can just extract the name from one of the Todos
    - remembering the SQL query from the "/dashboard/" route:
    ```
    const user_data = await db.query(
        "SELECT u.user_name, t.todo_id, t.description FROM users as u LEFT JOIN todos as t ON u.user_id = t.user_id WHERE u.user_id=$1",
        [req.user.id]
    )
    ```
- since we are getting all the Todo information here, it also makes more sense for us to just set all of the returned Todos as a state in our component, and pass that state to the `<ListTodo />` in the return HTML above
- so to do this, we are going to need to implement a state for the `name` that Dashboard will use, and then a state for `allTodos` that will get passed to `<ListTodo />`, and we will also need to make a `useEffect()` function that will call the API to get this data when the dashboard is initially loaded:
```
import InputTodo from '../TodoList/InputTodo';
import ListTodo from '../TodoList/ListTodo';
import { useEffect, useState } from 'react';

const Dashboard = ({ setAuth }) => {
    const [name, setName] = useState("")
    const [allTodos, setAllTodos] = useState([])

    const getProfile = async () => {
        try {
            const response = await fetch("/dashboard", {
                method: "GET",
                headers: { token: localStorage.token }
            });
            const data = await response.json();

            setName(data[0].user_name)
            setAllTodos(data)
        } catch (error) {
            console.error(error.message);
        }
    }

    useEffect(() => {
        getProfile()
    }, [])

    return (
        <>
            <main className="container mt-4 text-center mt-5">
                <div className="row d-flex flex-column justify-content-center">
                    <h1>{name}'s ToDo List</h1>
                    <InputTodo />
                    <ListTodo allTodos={allTodos}/>
                </div>
            </main>
            
        </>
    );
};

export default Dashboard;
```
- so now we have state t store the user's name in: `const [name, setName] = useState("")` and a state to store the Todos in: `const [allTodos, setAllTodos] = useState([])`
- when the page is loaded, `useEffect()` is called, which calls the `getProfile()` async function, once again, we are having `useEffect()` call a seperate `getProfile()` function so that we can make `getProfile()` asynchronous, since we cannot easily make `useEffect()` async on its own
- inside get profile, we make a GET request to the "/dashboard" route ( which is the same as "/dashboard/"), and even though it is just a GET, we have to include the options object so that we have a place to pass the `token` that was given to us by the backend when we first logged in
- we do this by just adding a simple `headers: { token: localStorage.token }` property to the object, and we also specify the method as GET since we have to do that if we are going to give options
- now we do not need to do anything special to access that token, remember how in the Login component we saved the token to the browsers local storage with `localStorage.setItem("token", data.token)`, well now we can just access it in the same way with `localStorage.token`, very easy considering we are working with soemthign we did not initialize ourselves!
- we then simply just await the response, and parse teh JSON response, and we know from the backend that our response, if successful, we be an an array in the form of:
```
[
    {
        "user_name": "zelda2",
        "todo_id": 5,
        "description": "slay gannon"
    },
    {
        "user_name": "zelda2",
        "todo_id": 7,
        "description": "buy a gallon of PCP"
    },
    {
        "user_name": "zelda2",
        "todo_id": 13,
        "description": "im sorry chris that wasn't nice"
    },
    {
        "user_name": "zelda2",
        "todo_id": 4,
        "description": "works?"
    }
]
```
- and this example is for the "zelda2" user I made when testing in postman when making the backend
- but in general it is an array of the `{ user_name, todo_id, description }` objects we defined in the SQL query
- so we can simply now set the state for the `name` state to the `user_name` with `setName(data[0].user_name)`, so we just choose the first todo in the aray and grab the name, and due to our authentication and well made query, each returned todo will always have the same `user_name`
- **also importantly,** if the user has no todos, for a new user, we still get a single object returned since we are doing a `LEFT JOIN` operation, and that would look like:
```
{
    "user_name": "zelda2",
    "todo_id": null,
    "description": null
}
``` 
- so we can still set the name, and simply load no todos since there are none
- however, we also want to set the `allTodos` state in the `useEffect()` function as well, and we do that with `setAllTodos(data)`, whcih is easy enough, and just gives the entire array shown above to the `allTodos` state
- in the last steo for this component, we then want to pass taht state to the `<ListTodo />` so that it can render the Todos without making its own fetch request, and we do that in the HTML return with `<ListTodo allTodos={allTodos}/>`
- this now means we have to edit ListTodo so that it can use this data without making its own request

### Updating ListTodo

- so originally the ListTodo component made its own fetch request on render, via `useEffect()` which called th async `getTodos` function, then inside the HTML return, we return a variable called `todoHTML`, which is its own arrow function that maps the fetched `todos` state onto the `<ListItem>` component
- the ListItem component does not need to be changed at all, since we are still grabbing the `description` and `todo_id` from each todo object that gets passed to it in the `todos` state array, instead we jsut need to change how the populate and update the `todos` state, since we no longer want to do it with a fetch request, but instead with the passed in `allTodos` array from the Dashboard component
- this could be as simple as changing `const todoHTML = todos.map((todoObj, idx) => {` to `const todoHTML = allTodos.map((todoObj, idx) => {`, and that works initially, but we need to have abetter way to keep track of the `allTodos` state within the ListTodo component, and rerender the componenet when `allTodos` cahnges, and this sounds perfect for `useffect()`
- Note, I will exclude the `ListItem` component definition here since it does not change, although we will need to change the `deleteTodo` method later to add the JWT authentication:
```
const ListTodo = ({ allTodos }) => {
    const [todos, setTodos] = useState([])

    const filterTodos = (todoId) => {
        // console.log("filterTodos initiated");
        setTodos(todos.filter((todo) => {
            if (todo.todo_id !== todoId) {
                return true
            } else {
                return false
            }
        }));
    };

    useEffect(() => {
        setTodos(allTodos);
    }, [allTodos])
    
    const todoHTML = todos.map((todoObj, idx) => {
        return (
            <ListItem todoObj={todoObj} key={idx} filterTodos={filterTodos} todos={todos} setTodos={setTodos}/>
        )
    }) 

    return (
        <main className="container mt-4">
            <div className="row d-flex flex-column justify-content-center">
                {todoHTML}
            </div>
        </main>
    )
}

export default ListTodo
```
- so as we can see we have erased the `getTodos()` function entirely, since we do not need to make a request anymore, and we can also see that the `filterTodos()` function actually has not changed whatsoever
- so now all we have to do is accept the `allTodos` state from Dashboard by deconstructing the prop: `const ListTodo = ({ allTodos }) => {`, and now we set the `todos` state directly in `useEffect`:
```
useEffect(() => {
    setTodos(allTodos);
}, [allTodos])
```
- so here we set `todos` to be `allTodos`, but notice that we also set a dependency of `useEffect` to be `[allTodos]`, what this does is tell `useEffect` to rerender our component each time one of the items in the array changes, in this case our only item is `allTodos`
- this is one of the great features of `useEffect`, and is also the reason we are typically apssing an empty array to it `[]`, since this tells `useEffect` it has no dependencies, and also stops `useEffect` from being called every single time a component is rerendered, which ends up in continuous fetch requests being made for some components when the empty array is not passed
- so now, everytime Dashboard updates `allTodos`, like when we add in the proper InputTodo functionality, it will pass the new `allTodos` to ListTodo, and since `allTodos` cahnged, `useEffect` will run and update the `todos` state to the new `allTodos`, and our list will be rendered properly
- so notice all of our todos are not in the `todos` state, so the mapping function for creating ListItem's works as expected: `todos.map((todoObj, idx) => {`

### Updating InputTodo & Adding Soft Refresh

- so I have decided to instead update all the components to work nicely with the new login functionality before adding the additional authentication features from the JWT tutorial 
- I will also add teh "soft reset" functionality here, and by that I mean the ability to update the todo list when we add or edit a todo, without having to refresh the entire page, which is a much nicer user experience, we already have this with the delete todos option, so having it for the whole app will be nice
- for teh InputTodo, we mainly need to change the fetch request so it works with our new backend, which needs JWT wuthentication
```
const InputTodo = ({ setTodosChange }) => {
    const [description, setDescription] = useState("");

    const updateDescription = (e) => {
        setDescription(e.target.value);
        // console.log(description);
    }

    const onSubmitForm = async (e) => {
        e.preventDefault();
        try {
            const myHeaders = new Headers();
            myHeaders.append("Content-Type", "application/json");
            myHeaders.append("token", localStorage.token);
            const body = { description };
            const response = await fetch("/dashboard/todos", {
                method: "POST",
                headers: myHeaders,
                body: JSON.stringify(body)
            });
            const data = await response.json();
            setTodosChange(true)
            setDescription("")
        } catch (err) {
            console.error(err.message);
        }
    }
...
```
- so here we can see that we have chnaged the route from "todos" to "dashboard/todos" as we have to for all of our new todolist routes
- but we also have added the `myHeaders` declaration for constructing the headers of our request, this is common practice in JS, and allows us to make a headers object as we go, then pass that Headers object to the fetch request as `headers: myHeaders`, and it deals with the formatting for us
- we do tis by calling the built in Headers class, and its constructor: `const myHeaders = new Headers();`, this creates a new Headers object for us, then we add items to our Headers object as key/value pairs with teh `append` method, such as: `myHeaders.append("Content-Type", "application/json");` and `myHeaders.append("token", localStorage.token);`
- so this lets us add teh content type header that we already had, and add the new JWT token as well
- when reading up on the HEaders object, it also has a list of forbidden heads it will not let us add, since they can mess with the ones needed by the browser I believe, which is ncie so we dont accidentally break stuff
- we are now ready to send the request and get the response, which we do as normal, now we can see that instead of calling `window.location = '/'` wich did a hard reset of teh page prevously, we instead have created, and passed into the InputTodo component, the state handler for a `todosChange` state, and we set that state to `true` with `setTodosChange(true)`
- this is a new addition that we make in the Dashboard comonent to keep track of when any change happens to our todos, and it is a simple boolean state:   
```
// Dashboard.js File //
const Dashboard = ({ setAuth }) => {
    const [name, setName] = useState("");
    const [allTodos, setAllTodos] = useState([]);
    const [todosChange, setTodosChange] = useState(false)
...
...
    useEffect(() => {
        getProfile();
        setTodosChange(false)
    }, [todosChange])

    return (
        <>
            <main className="container mt-4 text-center mt-5">
                <div className="row d-flex flex-column justify-content-center">
                    <h1>{name}'s ToDo List</h1>
                    <InputTodo setTodosChange={setTodosChange} />
                    <ListTodo allTodos={allTodos} setTodosChange={setTodosChange} />
                </div>
            </main>
            
        </>
    );
};
```
- so we see we create the new state at the top and set teh default of `todosChange` to `false`, then we pass the `setTodosChange` method to both the InputTodo and ListTodo components (we will go over ListTodo more later, for EditTodo)
- lastly, we see that we have included `[todosChange]` as a dependency for `useEffect`, so this means that `useEffect` will run everytime `todosChange` is cahnged
- so we can see the inital state is `false`, then when InputTodo adds a new Todo list item, it calls `setTodosChange(true)`, thus changing `todosChange` and causing `useEffect` to run, which calls `getProfile();` to get all the new Todo items, including the new one that was just added, thus updating the list, and lastly in `useEffect` we call `setTodosChange(false)` to reset the state so if another todo is added, or if another component calls `setTodosChange(true)`, the process happens again and the list is reloaded
- so in this way we have a method of "soft refreshing" the todo list anytime we want by just using the `todosChange` state
- **lastly**, if we notice in the `onSubmitForm()` code above, we also call `setDescription("")` at the end of the function, this is so after we add a todo, the input form goes back to being empty, and the text we just submitted doesnt stick around

### Updating EditTodos

- we can do similar updates tot he EditTodo component, which if we recall is added in as the button element in the ListItem component of ListTodo
- the first change is to add the same soft refresh functionality for after we edit a todo so that the page doesnt have to fully reload for the chnages to show
- we do this in a similar way, passing `setTodosChange` from Dashboard to Listtodo to EditTodo, and finally to EditModal, since the EditModal component is where the change is actually submitted and and the backend Edit API is called
- this happens in the onEdit submit handler for the edit modal form, which is shown below:
```
const onEdit = async (todoObj, e) => {
    e.preventDefault();
    try {
        const body = { description };
        const myHeaders = new Headers();
        myHeaders.append("Content-Type", "application/json");
        myHeaders.append("token", localStorage.token);

        const response = await fetch(`dashboard/todos/${todoObj.todo_id}`, {
            method: "PUT",
            headers: myHeaders,
            body: JSON.stringify(body),
        });
        setTodosChange(true)
    } catch (err) {
        console.error(err.message);
    }
    };
```
- here we can see we call teh `setTodosChange(true)` state change after we make the fetch API request
- we also of course have to update the PUT requets to the edit API by making it include the JWT token
- we do this again with the `Headers();` constructor, making a `myHeaders` object that we add teh content=type and JWT token headers too
- we then make the PUT request as normal 
- besides that small change to the handler, the EditTodo/EditModal component statys the same, as the majority of its functionality deals with making the modal work properly, which is inconsequential to our API

### Updating Delete Todo Function

- Lastly we have to update the `deleteTodo()` function we have for deleting todo elements, initially this is simple enough since all we really need to do is add the JWT token as a header to the DELETE request:
```
const deleteTodo = async (todoObj, filterTodos) => {
    try {
        const response = await fetch(`/dashboard/todos/${todoObj.todo_id}`, {
            method: "DELETE",
            headers: { token: localStorage.token }
        })
        const data = await response.json()
        filterTodos(todoObj.todo_id);
    } catch (error) {
        console.error(error.message);
    }
}
```
- we do not need to construct a `Header` object since we are just using a single header here
- this works as expected for deleting Todos, but we come across a new unintended interaction: when we delete all of our Todos, the next time we load the page we make an API call to fetch our todos of course, and the LEFT JOIN SQL query will return our user_name like we need it still, but since it returns a full single RECORD, we also get  `todo_id: null` and `description: null` properties being returned as well
- so what this does is when we build our ListTodos component, and call the maping function to map our returned todo array onto the ListItem component, we make a ListItem with a `null` description and ID, and end up with a weird empty todo on our list, and its ugly
- so therefore we have to add a conditional to the HTML return of ListTodos, so that we do not return or construct our ListItems when we have a single null return
- to do this we can make our HTML reutnr of ListItem be:
```
return (
    <main className="container mt-4">
        <div className="row d-flex flex-column justify-content-center">
            {
            todos.length !== 0 && 
                todos[0].todo_id !== null && 
                    (todoHTML)
            }
        </div>
    </main>
)
```
- so here what we are doing is using a JS escape in the HTML to add a little shortcut conditional, where we first test if we have a a todo list yet at all with `todos.length !== 0`, then we test if the first todo has a `null` id with `allTodos[0].todo_id !== null` (and we do this since the only way to get a `null` `todo_id` is if there are none, since they are made by default), and then if both of these are true we then allow it to constrct the `todoHTML`
- this notation works since JS tests the conditions one at a time, so the third condition in the "and" (`&&`) statements only gets executed if the previous are true, and in checking if `(todoHTML)` is `true` it gets executed to check, so this is like a little shortcut instead of sayign `if (todos.length !== 0 && allTodos[0].todo_id !== null) {(todoHTML)}`
- **also note, important.** we need to have the initial `todos.length !== 0` condition, even thugh it seems like it sould work fine just by checking the first todo for the null, but the issue is that this render will happen before the initial API call on load is done, so we will not have any items in `todos` at first, and `todos[0]` is undifined, and then it gets mad ):

## Adding JWT Token Handling & Verification

- now that all of our APIs play nicely with the JWT token, we want to make sure we are dealing with the JWT token correctly when the user logs our, and when they revisit the page while the token is still valid so they do not need to log back In

### JWT Logout

- if the user clicks the logout button, we want to clear the token from the local storage so that the next erson to use the device doesnt have access to their account if they go to the same site
- we do this with a simple logout button and handler that will remove the token, first we add a logout button to the HTML return of dashboard. which we had then removed previously, but now it will be better:
```
return (
    <>
        <main className="container text-center mt-4">
            <div className="row d-flex flex-column justify-content-center">
                <div className='d-flex flex-column w-100 align-items-center p-0'>
                    <button className="btn btn-primary align-self-end" onClick={logout}>Logout</button>
                    <h1>{name}'s ToDo List</h1>
                </div>
                <InputTodo setTodosChange={setTodosChange} />
                <ListTodo allTodos={allTodos} setTodosChange={setTodosChange} />
            </div>
        </main>
        
    </>
);
```
- one note on the CSS here is that i find it difficult to have a flexbox here where I want the name to be center then the logout button to be parallel to the name but to the right, we can do this with absolute positioning of coruse but also I feeel like people try to avoid that when possible
- instead what I did here was make it a flex-column flexbox justified to center, then align the logout button end so it goes to one side, this also clearly stacks them, which I didnt actually expect at first, but now I like it stacked since the logout is out of the way of the main viiew, maybe will make a banner at the top later instead for search/logout
- okay but the important functionality here is that the button calls teh logout handler:
```
const logout = (e) => {
    e.preventDefault()
    localStorage.removeItem("token")
    setAuth(false)
}
```
- in the logout handler, we just prevent default so it doesnt refresh, then we do `localStorage.removeItem("token")` to remove the JWT token from out local storage, then simply `setAuth(false)` to force the user to go back to the login page
- if we now try to logout on our site, we can see the token disappear from the applications page of the dev tools as well, it works!

### Adding Token Verification for Returning Users

- okay so now we want a user to be able to be directed right to their page when they arrive at the website if they still have a valid JWT authentication
- we already have this in our backend with the "auth/verify" route, but now we need to call this route in the front end
- we want to call this route right in the App component so that it gets called when the webpage loads
```
function App() {
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  const setAuth = (boolean) => {
    setIsAuthenticated(boolean);
  }

  const verifyToken = async () => {
    try {
      const response = await fetch("auth/verify",
        {
          method: "GET",
          headers: { token: localStorage.token}
        });
      const data = await response.json();
      data === true ? (setAuth(true)) : (setAuth(false));

    } catch (error) {
      console.error(error.message);
    }
  };

  useEffect(() => {
    verifyToken();
  }, []);
```
- so to App we have added a `useEffect()` that will run when the page loads, and all it does it call `verifyToken()` which we have inplemented above
- inside `verifyToken()`, we just make a GET request to the "auth/dashboard" route, and try to add our token as a header, we know that this route returns `true` as the response if the token is verified so we simpyl test that `data === true ? (setAuth(true)) : (setAuth(false));` and set the authentication state to either `true` or `false` accordingly
- we have to make sure not to use a `if (data)` syntax here, since this will return true for all resonses as long as it exists, so our response if we are unverified is a 403 status with "Not Authorized" text, and since there is text `data` resolves as `true`, so we have to use the EXACTLY equal operator `===`
- so now isAuthenticated is true, so we get redirect tot he dashboard immediately